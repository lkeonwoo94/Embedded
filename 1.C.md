# C programming

1. [Build Process - C로 짜여진 프로그램은 어떻게 Board(Target Embedded system)위로 올라갈까요?](#1)
2. [Embedded에 필요한 기초 C언어](#2)


---

<div id="1"></div>

## 1. C로 짜여진 프로그램은 어떻게 Board위로 올라갈까요?

우리가 짠 C 프로그램은 .c file로 C program 소스코드가 저장되는 것은 아시죠.    
.c file은 이제 보드가 이해할 수 있는 ELF 형식의 file 로 변해야 합니다.    

ELF file은 뭘까요?
컴퓨터는 오직 0과 1만 이해할 수 있습니다. 사람은 int라는 것이 4byte의 정수형을 의미한다는 것을 알지만 컴퓨터는 이해할 수 없죠.
이를 위해서 약속된 규약( 예: 0011 은 int라고 부르자 ) 이 필요합니다. 이것을 **ISA**(Instruction Set Architecture) 라고 부르고 Hardware를 설계하는 사람이 규약을 만들어 냅니다.

C code는 **Compiler**를 통해서 **특정 Core**( ISA는 다 똑같지 않아요)에 맞는 Assembly language로 변환시켜 줍니다.
이 Assembly language는 C code의 #include 했던 lib를 포함하고 있지 않기 때문에, 여러 Assembly file을 합쳐주는 작업이 필요해요.
이를 **Linking** 작업이라 합니다. **Linker**를 통해서 .obj file들이 합쳐지고 합쳐진 결과물이 **ELF** 형식의 파일이 됩니다.

그림으로 같이 살펴볼까요?

> Build Process

```
<-------------------------------------------------------------Build Process------------------------------------------------------------->

                                                               +-> map file
        Preprocessing            Compiler              Linker  |                 format converter
C/C++ -----------------> .i file ----------> .obj file -----------> ELF / DWARF ---------------------> hex file -----> Flash/ROM programmer
(.c file)       (.i 는 생성됐다가 사라져요)      ^                     ^
(.h file)                                        |                     |
                                                 |                     |
                               Assembly ---------+                 lib (.a file)& 
                               (.s file)  Assembler                 start-up code
```

Map file이 나와서 당황스러우셨죠? 이것은 [2장 Memory]() 에서 얘기할 거에요. 지금은 잠시 넘어가도록 해요.    
이제 Embedded를 위한 C programming 기초와 Build에 필요한 나머지 Compiler, Linker 들을 차근차근히 알아보도록 해요.

---

<div id="2"></div>

## 2. Embedded에 필요한 기초 C언어




---

> C 전처리문
```C
#define foo(x) #x    // # 연산자는 매개변수를 문자화 하는 연산자입니다              
#define foo(x) X##n   // ## 연산자는 토큰들을 결합합니다. X(1)이라고 하면 X1 변수를 입력한것과 동일합니다.
```

