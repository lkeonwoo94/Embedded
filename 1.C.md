# C programming

1. [Build Process - C로 짜여진 프로그램은 어떻게 Board(Target Embedded system)위로 올라갈까요?](#1)
2. [Embedded에 필요한 기초 C언어](#2)
3. [Preprocess](#3)
4. [Compiler](#4)
5. [Linker](#5)
Appendix A. C++

---

<div id="1"></div>

## 1. C로 짜여진 프로그램은 어떻게 Board위로 올라갈까요?

우리가 짠 C 프로그램은 .c file로 C program 소스코드가 저장되는 것은 아시죠.    
.c file은 이제 보드가 이해할 수 있는 ELF 형식의 file 로 변해야 합니다.    

ELF file은 뭘까요?
컴퓨터는 오직 0과 1만 이해할 수 있습니다. 사람은 int라는 것이 4byte의 정수형을 의미한다는 것을 알지만 컴퓨터는 이해할 수 없죠.
이를 위해서 약속된 규약( 예: 0011 은 int라고 부르자 ) 이 필요합니다. 이것을 **ISA**(Instruction Set Architecture) 라고 부르고 Hardware를 설계하는 사람이 규약을 만들어 냅니다.

C code는 **Compiler**를 통해서 **특정 Core**( ISA는 다 똑같지 않아요)에 맞는 Assembly language로 변환시켜 줍니다.
이 Assembly language는 C code의 #include 했던 lib를 포함하고 있지 않기 때문에, 여러 Assembly file을 합쳐주는 작업이 필요해요.
이를 **Linking** 작업이라 합니다. **Linker**를 통해서 .obj file들이 합쳐지고 합쳐진 결과물이 **ELF** 형식의 파일이 됩니다.

그림으로 같이 살펴볼까요?

> Build Process

```
<-------------------------------------------------------------Build Process------------------------------------------------------------->

                                                               +-> map file
        Preprocessing            Compiler              Linker  |                 format converter
C/C++ -----------------> .i file ----------> .obj file -----------> ELF / DWARF ---------------------> hex file -----> Flash/ROM programmer
(.c file)       (.i 는 생성됐다가 사라져요)      ^                     ^                                                    |
(.h file)                                        |                     |                                                   | 프로그램 실행 시(보드에서 전원 켰을  !! 지금은 아니에요)
                                                 |                     |                                                   |
                               Assembly ---------+                 lib (.a file)&                                          v
                               (.s file)  Assembler                 start-up code                                         RAM
```

Map file이 나와서 당황스러우셨죠? 이것은 [2장 Memory]() 에서 얘기할 거에요. 지금은 잠시 넘어가도록 해요.    
이제 Embedded를 위한 C programming 기초와 Build에 필요한 나머지 Compiler, Linker 들을 차근차근히 알아보도록 해요.

```
Assembly 단계 .s file 사용처 : start-up code, vector table handler
Linking 단계 : linker script file (ld, icf) :: map file을 생성하기 위해 memory section을 지정해줌
```
`잡지식- 임베디드에서 왜 C가 많이쓰일까요?`
```
C언어를 배우면 언어의 특징으로 이식성이 높다는 말이 나옵니다. 이식성이 높다는건 무슨말일까요?
이식성이 높다는 것은 다양한 컴파일러가 지원이 된다는 것입니다.
위에서 컴파일러는 CPU플랫폼에 의존하고, CPU플랫폼마다 다른 어셈블리어를 구현한다고 했는데요.
그러면 C-컴파일러-어셈블리어 를 이어주기 위해 다양한 컴파일러가 존재해야돼요. CPU제조사에서는 이와 호환되는 컴파일러를 제공하고 있고
그렇기 때문에 C는 이식성이 높고, 임베디드에서 많이 쓰인다는 말이 나왔어요.
```

---

<div id="2"></div>

## 2. Embedded에 필요한 기초 C언어
2-1. [자료형과 byte의 이해](#2-1)    
2-2. [다양한 pointer 이해](#2-2)    
2-3. [Byte Ordering](#2-3)

<div id="2-1"></div>

### 2-1.자료형과 byte의 이해

> * 문자열 상수 = 주소값이다 (4 byte) (주소는 바꿀수 없다. 변수가 아니다)
```C
char str[80] = "hyundai" // 배열 선언과 동시에 초기화 (O)
str = "autron" // 배열에 문자열을 바로 대입할 수 없다(X)
```
> * 프로세서가 32bit면, 32bit크기 만큼의 자료형이 제일 빠르다 => 그래서 int (4byte=32bit)를 사용한다.
> * char는 실제로 메모리에 들어갈 때는 4byte(정수형 int)로 **승격** 돼서 들어간다 (자료형의 승격) (type이 다른경우 MSB로 padding)
> * Byte ordering : little-endian / Big-endian - 중요한것은 1 Byte(8bit) 단위로 ordering이다.
>   * union bit field 시 조심하자.
`쓸데없는 팁 : case 0...5: 하면 0~5까지 범위를 설정할 수 있다`
---

<div id="2-2"></div>

### 2-2.다양한 pointer 이해

`포인터의 size는 프로세서의 bit수에 의존한다 (ex. 32bit-cpu 일때, ptr 사이즈=32bit)`    
`배열과 포인터는 같다. 포인터도 메모리 상에 잡힌 변수다`    
`포인터는 언제쓰죠 ? 함수끼리 argv 전달할 때 ! - 메모리상에서 전달하기 편하다`    

| char `*`pa = &a (address)|
|--|
| L-value : ptr  , R-value : addr|

> **해석순서**      
> `1.()   2.[]   3.*` -> **먼저 해석된 애가 진짜**
* char `*`pa[3] : 포인터(로된) **배열**
```
+-------+-------+-------+
|*ptr[0]|*ptr[1]|*ptr[2]|
+-------+-------+-------+
```
* char (`*`ap)[4] : 배열(을가리키는) **포인터** : "**2차원 배열**"을 가리키는 포인터 변수 (2차원 배열을 함수로 넘겨줄 때는 배열의 포인터AP로 받음 : 설계 중요 고려요소) == 2차원 배열 char ap[number][4]와 같다.
```
ptr -------> +------+
             | char |
             | char |
             | char |
             | char |
             +------+
```
* char (`*`fp)(char) : 함수(를가리키는) **포인터** ``` ptr ----> function ```
* char (`*`fpa[3])(char) : 함수(를가리키는) 포인터(들의) **배열** 
```
+---------+
| *fpa[0] |  -----> function 
| *fpa[1] |  -----> function 
| *fpa[2] |  -----> function 
+---------+
```

---

> 배열에서 포인터
> * int arr[3] 일때, 전체길이는 `3*4byte`.
> * arr+1 = (addr) +1 = (int size addr) +1 = 4byte 만큼 증가.
> * &arr+1 = **12byte** 만큼 증가. (배열 arr를 가리키는 주소는 &arr. )
---


> 초기선언 후 사용(L-value & R-value 모두)
> *  `*`ary == **ary[0] == `*`(ary+0)** == `*`(ary + 0`*`sizeof(type_size))  : value
> * **ary == &ary[0] == (ary+0)** == (ary + 0`*`sizeof(type)) , ary++도 가능하다  : address 
` 포인터의 주소를 찍고 싶을땐 ? &L-value가 아니고 !! 이중포인터로 **d_ptr=ary 해서 포인터의 addr를 잡아줘야합니다 ! `
    
---

> ptr 타입캐스트
> * ptr type cast : `*`(int `*`)ptr // 1. ptr를 int형 pointer (int`*`)로 변환. 2. int size의 ptr의 `*`(value)로 사용
                : (int `*`)ptr // type cast 後 addr로 사용
       
---

> 잠금 : const는 바로 앞을 수식
> * type const `*`ptr : target value 를 lock // const (value)
> * type `*` const ptr : addr를 lock // * const (addr) = **고정된주소**의 값을 참조
---

> 증감연산
> * char `*`ptr++ : 자료형size 만큼 addr 증가     // 1.addr증감연산. 2.`*`(value)
  
---

`자잘한 팁`
```
* void `*`p : C언어에서 유일하게 자료형을 가지지 않는다. 아무거나 가리킬 수 있고 절대 컴퓨터에서 에러가 나지 않는다.
  * `*(type*)p 로 type casting 해서 사용`
배열명 = 포인터 상수
함수명 = 포인터 = 주소
포인터+ 포인터 연산 (x)
포인터 - 포인터 연산 (o)
(*p).name == p->name 과 동치
```
---
<div id="2-3"></div>

### 2-3.Byte Ordering
> Little-Endian , Bid-Endian에 대한 이야기는 많이 들어보셨을겁니다.
> 매번 헷갈리게 만들지만이 "Ordering" 이라는 것은 **"1 Byte"** 단위로 이루어 집니다.
> 다시말하면 **8bit** 단위로 이루어지는 것이지요.
> 8bit 는 hex 형식으로 0x00 두자리이며 이를 2진법으로 펼치면
> 0b_0000_0000 입니다.
> (bit 단위가 아니라는것에 주의하세요)

---

<div id="3"></div>

## 3. Preprocess

> C 전처리문
```C
#define foo(x) #x    // # 연산자는 매개변수를 문자화 하는 연산자입니다              
#define foo(x) X##n   // ## 연산자는 토큰들을 결합합니다. X(1)이라고 하면 X1 변수를 입력한것과 동일합니다.
```
 #define (매크로함수) 를 사용하면 stack으로 영역이 잡히지 않는다. 속도가 빨라지며 최적화에 사용된다.

```
          Preprocessor
.h file----------------> .i file (하나의 파일로 합쳐진다. 이렇게 만들어놔야 어셈블리로 처리하기 쉽겠죠?)
.c file ┘
```
```
컴파일시 -E 옵션을 사용하면 .i file을 생성할 수 있다.
-EC 옵션을 사용하면 .i file에서 C code에 작성됐던 주석을 사라지게 하지 않는다.
(원래는 사라져요)
```
---

<div id="4"></div>

## 4. Compiler

4-1. [컴파일러와 인터프리터 차이점이 뭘까요](#4-1)
4-2. [컴파일러는 무엇인가요](#4-2)
4-3. [컴파일러 옵션(선택적 컴파일은 어디에 쓰이는가)](#4-3)

<div id="4-1"></div>
### 4-1.Compiler vs Interpreter
```
             |       +----------+    +-------------+
   Translate |       | Compiler |    |             |
             v       +----------+    |             |
             |       +----------+    | Interpreter |
   Execute   |       |  Process |    |             |
             v       +----------+    +-------------+
              

```

<div id="4-2"></div>
### 4-2.컴파일러는 무엇인가요

컴파일러는 C언어를 어셈블리어로 바꿔줘요. 원래는 .s file이 나오는데, 요즘 컴파일러는 좋아서 한방에 바로 .obj 파일까지 만들어줘요.
컴파일러는 어셈블리어와 뗄 수 없는 관계에요. 출력물을 열어보시면 어셈블리어로 되어있어요(아래어셈코드)
여기보시면 MOV 이런 명령어와 r0,r1와같은 register들이 보여요.
```
MOV r0,#1; // 변수=1; // #1같은 키워드는 '컴퓨터구조'를 공부하셨으니 알거라고 생각하고 넘어갈게요.
```
MOV와 같은 어셈블리명령어는 **mnemonic** 이라고도 불리고요.
r0,r1 와 같은 register는 CPU register 라고 불러요.
학부때 다뤘던 GPGCON 이런 레지스터는 Hardware register라고 불러요.(다른거에요)

컴파일러는 어셈블리와 뗄 수 없는 관계라고 했는데요, ARM에서는 Assembly와 register 사이에는 **ATPCS 규약**(ARM thumb)이 존재해요. (ARM에서만 먹혀요 !!!)
r0,r1 이런 CPU register가 무엇인지 알기위해서는 ATPCS 규약을 알고가는게 좋아요.
`ATPCS 규약은 점차 발전해왔어요.`
```
PCS -> APCS -> TPCS -> ATPCS -> AAPCS 
결국 지금 사용되는 Procedure Call Standard (Register 사용법)은 이름 하야 AAPCS라고 부르는 게 맞겠습니다.
```

뒤에서 ARM Hardware 관련해서 다시 이야기 하겠지만 지금은 간단하게만 보고 지나가도록 해요.
```
==========================================================================
레지스터  | APCS | 역할
--------------------------------------------------------------------------
r0  | a1 | 함수인자1 / ret값 전달 / 범용 스크래치 레지스터
r1  | a2 | 함수인자2 / ret값 전달 / 범용 스크래치 레지스터
r2  | a3 | 함수인자3 / ret값 전달 / 범용 스크래치 레지스터
r3  | a4 | 함수인자4 / ret값 전달 / 범용 스크래치 레지스터
r4  | v1 | 변수용 레지스터 1
r5  | v2 | 변수용 레지스터 2
r6  | v3 | 변수용 레지스터 3
r7  | v4 | 변수용 레지스터 4
r8  | v5 | 변수용 레지스터 5
r9  | v6/sb | 변수용 레지스터 6/ RWRP로 컴파일할 때 베이스 주소 저장
r10 | v7/sl | 변수용 레지스터 7/ 스택 limit 주소 저장
r11 | fp | frame pointer로 사용
r12 | ip | 범용 스크래치 레지스터
r13 | sp | 스택의 현재 위치 저장하는 레지스터
r14 | lr | 링크 레지스터 (ret 주소 저장)
r15 | pc | 프로그램 카운터
==========================================================================

- 함수인자 : 처음 4개 까지는 r0~r3 사용, 추가 인자는 stack 사용 (ret 값이 1reg(4bye)를 넘어가면 r0~r3까지 확장해서 사용)
- 함수의 지역변수: r4~r10까지 사용, 추가변수는 stack 사용
- 함수의 ret값 : r0
- 스크래치: 연습장이라고 생각하세요
```

<div id="4-3"></div>
### 4-3.컴파일러 옵션(선택적 컴파일은 어디에 쓰이는가)

전처리문에 #define이 기억나시나요? 전처리기에서 의해 처리되었지만     
컴파일러에 의해 전처리를 할 수도 있답니다.    
컴파일시 -D 옵션을 주면 #define 과 같고요, -U 옵션을 주면 #undef와 같습니다.    
이것은 **선택적 컴파일** 시에 사용합니다. (여러개 중에 버전선택과 같은)    
```C
-DA (D 띄우고 A 아니에요. 붙여써야해요)
예)
#ifdef A
    #def ~~~
#elif defined B
    #def ~~~
#endif
```
또한 다른 옵션으로 DWARF라는 디버깅시에 사용하는 포맷을 생성할 수도 있어요.

---


<div id="5"></div>

## 5. Linker



---
C++
Class : 붕어빵 틀
객체=instance = 붕어빵
```
Class+
     └ Constructor : 생성자 (객체 생성시 자동실행)
     └ method : member function
            └ get-method 
            └ set-method
     └ Destructor : 소멸자 (User가 정의)
     
```
Overload : 매개변수 인자가 여러개 ( ex. 연산자 오버로딩)
Override : 덮어쓰기(함수명이 같은경우) => virtual로 동적결합한다 (가상함수) , 가상함수:"함수 내용을 정의하지 않고, 자식 class에 의해 내용 결정"

---
어디에 넣어야 할까 ..
static local variable 특징 2가지 : block을 벗어나도 소멸되지 않는다.

process는 실행중인 program으로 , stack ,data, code   memory 영역을 독립적으로 가지고 있다.
Thread는 process 내의 data, code 영역을 **공유** 하고 stack 영역을 독립적으로 가지고 있다.




