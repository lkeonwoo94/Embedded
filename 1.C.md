# C programming

1. [Build Process - C로 짜여진 프로그램은 어떻게 Board(Target Embedded system)위로 올라갈까요?](#1)
2. [Embedded에 필요한 기초 C언어](#2)


---

<div id="1"></div>

## 1. C로 짜여진 프로그램은 어떻게 Board위로 올라갈까요?

우리가 짠 C 프로그램은 .c file로 C program 소스코드가 저장되는 것은 아시죠.    
.c file은 이제 보드가 이해할 수 있는 ELF 형식의 file 로 변해야 합니다.    

ELF file은 뭘까요?
컴퓨터는 오직 0과 1만 이해할 수 있습니다. 사람은 int라는 것이 4byte의 정수형을 의미한다는 것을 알지만 컴퓨터는 이해할 수 없죠.
이를 위해서 약속된 규약( 예: 0011 은 int라고 부르자 ) 이 필요합니다. 이것을 **ISA**(Instruction Set Architecture) 라고 부르고 Hardware를 설계하는 사람이 규약을 만들어 냅니다.

C code는 **Compiler**를 통해서 **특정 Core**( ISA는 다 똑같지 않아요)에 맞는 Assembly language로 변환시켜 줍니다.
이 Assembly language는 C code의 #include 했던 lib를 포함하고 있지 않기 때문에, 여러 Assembly file을 합쳐주는 작업이 필요해요.
이를 **Linking** 작업이라 합니다. **Linker**를 통해서 .obj file들이 합쳐지고 합쳐진 결과물이 **ELF** 형식의 파일이 됩니다.

그림으로 같이 살펴볼까요?

> Build Process

```
<-------------------------------------------------------------Build Process------------------------------------------------------------->

                                                               +-> map file
        Preprocessing            Compiler              Linker  |                 format converter
C/C++ -----------------> .i file ----------> .obj file -----------> ELF / DWARF ---------------------> hex file -----> Flash/ROM programmer
(.c file)       (.i 는 생성됐다가 사라져요)      ^                     ^
(.h file)                                        |                     |
                                                 |                     |
                               Assembly ---------+                 lib (.a file)& 
                               (.s file)  Assembler                 start-up code
```

Map file이 나와서 당황스러우셨죠? 이것은 [2장 Memory]() 에서 얘기할 거에요. 지금은 잠시 넘어가도록 해요.    
이제 Embedded를 위한 C programming 기초와 Build에 필요한 나머지 Compiler, Linker 들을 차근차근히 알아보도록 해요.

```
Assembly 단계 .s file 사용처 : start-up code, vector table handler
Linking 단계 : linker script file (ld, icf) :: map file을 생성하기 위해 memory section을 지정해줌
```

---

<div id="2"></div>

## 2. Embedded에 필요한 기초 C언어
2-1. 자료형과 byte의 이해
2-2. 다양한 pointer 이해

> 자료형과 byte의 이해
* 문자열 상수 = 주소값이다 (4 byte) (주소는 바꿀수 없다. 변수가 아니다)
```C
char str[80] = "hyundai" // 배열 선언과 동시에 초기화 (O)
str = "autron" // 배열에 문자열을 바로 대입할 수 없다(X)
```
* 프로세서가 32bit면, 32bit크기 만큼의 자료형이 제일 빠르다 => 그래서 int (4byte=32bit)를 사용한다.
* char는 실제로 메모리에 들어갈 때는 4byte(정수형 int)로 **승격** 돼서 들어간다 (자료형의 승격) (type이 다른경우 MSB로 padding)

> 다양한 pointer 이해
포인터의 size는 프로세서의 bit수에 의존한다 ( ex. 32bit-cpu 일때, ptr 사이즈=32bit)

* char `*`pa = &a (address)
* `*`ary == ary[0] == `*`(ary+0) == `*`(ary + 0`*`sizeof(type))  : value
* ary == &ary[0] == (ary+0) == (ary + 0`*`sizeof(type))  : address

***pa = pa[a][b]
**pa=pa[a]
*pa=pa=address

* char `*`pa[3] : 포인터 배열
* char (`*`ap)[4] : 배열 포인터 : "**2차원 배열**"을 가리키는 포인터 변수 (2차원 배열을 함수로 넘겨줄 때는 배열의 포인터AP로 받음 : 설계 중요 고려요소)
* char (`*`fp)(char) : 함수 포인터
* char (`*`fpa[3])(char) : 함수 포인터 배열


* const `*`ptr : target value 를 lock
* `*` const ptr : addr를 lock

* void `*`p : C언어에서 유일하게 자료형을 가지지 않는다. 아무거나 가리킬 수 있고 절대 컴퓨터에서 에러가 나지 않는다.

* char `*`ptr++ : 자료형size 만큼 addr 증가

배열명 = 포인터 상수
함수명 = 포인터

포인터+ 포인터 연산 (x)
포인터 - 포인터 연산 (o)



---
static local variable 특징 2가지 : block을 벗어나도 소멸되지 않는다.

process는 실행중인 program으로 , stack ,data, code   memory 영역을 독립적으로 가지고 있다.
Thread는 process 내의 data, code 영역을 **공유** 하고 stack 영역을 독립적으로 가지고 있다.







---

> C 전처리문
```C
#define foo(x) #x    // # 연산자는 매개변수를 문자화 하는 연산자입니다              
#define foo(x) X##n   // ## 연산자는 토큰들을 결합합니다. X(1)이라고 하면 X1 변수를 입력한것과 동일합니다.
```
 #define (매크로함수) 를 사용하면 stack으로 영역이 잡히지 않는다. 속도가 빨라지며 최적화에 사용된다.
 
---


---
C++
Class : 붕어빵 틀
객체=instance = 붕어빵
```
Class+
     └ Constructor : 생성자 (객체 생성시 자동실행)
     └ method : member function
            └ get-method 
            └ set-method
     └ Destructor : 소멸자 (User가 정의)
     
```
Overload : 매개변수 인자가 여러개 ( ex. 연산자 오버로딩)
Override : 덮어쓰기(함수명이 같은경우) => virtual로 동적결합한다 (가상함수) , 가상함수:"함수 내용을 정의하지 않고, 자식 class에 의해 내용 결정"
