# C programming

1. [Build Process - C로 짜여진 프로그램은 어떻게 Board(Target Embedded system)위로 올라갈까요?](#1)
2. [Embedded에 필요한 기초 C언어](#2)
3. [Preprocess](#3)
4. [Compiler](#4)
5. [Linker](#5)
Appendix A. C++

---

<div id="1"></div>

## 1. C로 짜여진 프로그램은 어떻게 Board위로 올라갈까요?

우리가 짠 C 프로그램은 .c file로 C program 소스코드가 저장되는 것은 아시죠.    
.c file은 이제 보드가 이해할 수 있는 ELF 형식의 file 로 변해야 합니다.    

ELF file은 뭘까요?
컴퓨터는 오직 0과 1만 이해할 수 있습니다. 사람은 int라는 것이 4byte의 정수형을 의미한다는 것을 알지만 컴퓨터는 이해할 수 없죠.
이를 위해서 약속된 규약( 예: 0011 은 int라고 부르자 ) 이 필요합니다. 이것을 **ISA**(Instruction Set Architecture) 라고 부르고 Hardware를 설계하는 사람이 규약을 만들어 냅니다.

C code는 **Compiler**를 통해서 **특정 Core**( ISA는 다 똑같지 않아요)에 맞는 Assembly language로 변환시켜 줍니다.
이 Assembly language는 C code의 #include 했던 lib를 포함하고 있지 않기 때문에, 여러 Assembly file을 합쳐주는 작업이 필요해요.
이를 **Linking** 작업이라 합니다. **Linker**를 통해서 .obj file들이 합쳐지고 합쳐진 결과물이 **ELF** 형식의 파일이 됩니다.

그림으로 같이 살펴볼까요?

> Build Process

```
<-------------------------------------------------------------Build Process------------------------------------------------------------->

                                                               +-> map file
        Preprocessing            Compiler              Linker  |                 format converter
C/C++ -----------------> .i file ----------> .obj file -----------> ELF / DWARF ---------------------> hex file -----> Flash/ROM programmer
(.c file)       (.i 는 생성됐다가 사라져요)      ^                     ^                                                    |
(.h file)                                        |                     |                                                   | 프로그램 실행 시(보드에서 전원 켰을  !! 지금은 아니에요)
                                                 |                     |                                                   |
                               Assembly ---------+                 lib (.a file)&                                          v
                               (.s file)  Assembler                 start-up code                                         RAM
```

Map file이 나와서 당황스러우셨죠? 이것은 [2장 Memory]() 에서 얘기할 거에요. 지금은 잠시 넘어가도록 해요.    
이제 Embedded를 위한 C programming 기초와 Build에 필요한 나머지 Compiler, Linker 들을 차근차근히 알아보도록 해요.

```
Assembly 단계 .s file 사용처 : start-up code, vector table handler
Linking 단계 : linker script file (ld, icf) :: map file을 생성하기 위해 memory section을 지정해줌
```

---

<div id="2"></div>

## 2. Embedded에 필요한 기초 C언어
2-1. [자료형과 byte의 이해](#2-1)    
2-2. [다양한 pointer 이해](#2-2)    

<div id="2-1"></div>

> 자료형과 byte의 이해

>> * 문자열 상수 = 주소값이다 (4 byte) (주소는 바꿀수 없다. 변수가 아니다)
```C
char str[80] = "hyundai" // 배열 선언과 동시에 초기화 (O)
str = "autron" // 배열에 문자열을 바로 대입할 수 없다(X)
```
>> * 프로세서가 32bit면, 32bit크기 만큼의 자료형이 제일 빠르다 => 그래서 int (4byte=32bit)를 사용한다.
>> * char는 실제로 메모리에 들어갈 때는 4byte(정수형 int)로 **승격** 돼서 들어간다 (자료형의 승격) (type이 다른경우 MSB로 padding)
>> * Byte ordering : little-endian / Big-endian - 중요한것은 1 Byte(8bit) 단위로 ordering이다.
>>   * union bit field 시 조심하자.
`쓸데없는 팁 : case 0...5: 하면 0~5까지 범위를 설정할 수 있다`
---

<div id="2-2"></div>

> 다양한 pointer 이해

`포인터의 size는 프로세서의 bit수에 의존한다 (ex. 32bit-cpu 일때, ptr 사이즈=32bit)`    
`배열과 포인터는 같다. 포인터도 메모리 상에 잡힌 변수다`    
`포인터는 언제쓰죠 ? 함수끼리 argv 전달할 때 ! - 메모리상에서 전달하기 편하다`    

| char `*`pa = &a (address)|
|--|
| L-value : ptr  , R-value : addr|

> **해석순서**      
> `1.()   2.[]   3.*` -> **먼저 해석된 애가 진짜**
* char `*`pa[3] : 포인터(로된) **배열**
```
+-------+-------+-------+
|*ptr[0]|*ptr[1]|*ptr[2]|
+-------+-------+-------+
```
* char (`*`ap)[4] : 배열(을가리키는) **포인터** : "**2차원 배열**"을 가리키는 포인터 변수 (2차원 배열을 함수로 넘겨줄 때는 배열의 포인터AP로 받음 : 설계 중요 고려요소) == 2차원 배열 char ap[number][4]와 같다.
```
ptr -------> +------+
             | char |
             | char |
             | char |
             | char |
             +------+
```
* char (`*`fp)(char) : 함수(를가리키는) **포인터** ``` ptr ----> function ```
* char (`*`fpa[3])(char) : 함수(를가리키는) 포인터(들의) **배열** 
```
+---------+
| *fpa[0] |  -----> function 
| *fpa[1] |  -----> function 
| *fpa[2] |  -----> function 
+---------+
```

---

> 배열에서 포인터
> * int arr[3] 일때, 전체길이는 `3*4byte`.
> * arr+1 = (addr) +1 = (int size addr) +1 = 4byte 만큼 증가.
> * &arr+1 = **12byte** 만큼 증가. (배열 arr를 가리키는 주소는 &arr. )
---


> 초기선언 후 사용(L-value & R-value 모두)
> *  `*`ary == **ary[0] == `*`(ary+0)** == `*`(ary + 0`*`sizeof(type_size))  : value
> * **ary == &ary[0] == (ary+0)** == (ary + 0`*`sizeof(type)) , ary++도 가능하다  : address 
` 포인터의 주소를 찍고 싶을땐 ? &L-value가 아니고 !! 이중포인터로 **d_ptr=ary 해서 포인터의 addr를 잡아줘야합니다 ! `
    
---

> ptr 타입캐스트
> * ptr type cast : `*`(int `*`)ptr // 1. ptr를 int형 pointer (int`*`)로 변환. 2. int size의 ptr의 `*`(value)로 사용
                : (int `*`)ptr // type cast 後 addr로 사용
       
---

> 잠금 : const는 바로 앞을 수식
> * type const `*`ptr : target value 를 lock // const (value)
> * type `*` const ptr : addr를 lock // * const (addr) = **고정된주소**의 값을 참조
---

> 증감연산
> * char `*`ptr++ : 자료형size 만큼 addr 증가     // 1.addr증감연산. 2.`*`(value)
  
---

`자잘한 팁`
```
* void `*`p : C언어에서 유일하게 자료형을 가지지 않는다. 아무거나 가리킬 수 있고 절대 컴퓨터에서 에러가 나지 않는다.
  * `*(type*)p 로 type casting 해서 사용`
배열명 = 포인터 상수
함수명 = 포인터 = 주소
포인터+ 포인터 연산 (x)
포인터 - 포인터 연산 (o)
(*p).name == p->name 과 동치
```


---

<div id="3"></div>

## 3. Preprocess

> C 전처리문
```C
#define foo(x) #x    // # 연산자는 매개변수를 문자화 하는 연산자입니다              
#define foo(x) X##n   // ## 연산자는 토큰들을 결합합니다. X(1)이라고 하면 X1 변수를 입력한것과 동일합니다.
```
 #define (매크로함수) 를 사용하면 stack으로 영역이 잡히지 않는다. 속도가 빨라지며 최적화에 사용된다.
 
---

<div id="4"></div>

## 4. Compiler
---

<div id="5"></div>

## 5. Linker



---
C++
Class : 붕어빵 틀
객체=instance = 붕어빵
```
Class+
     └ Constructor : 생성자 (객체 생성시 자동실행)
     └ method : member function
            └ get-method 
            └ set-method
     └ Destructor : 소멸자 (User가 정의)
     
```
Overload : 매개변수 인자가 여러개 ( ex. 연산자 오버로딩)
Override : 덮어쓰기(함수명이 같은경우) => virtual로 동적결합한다 (가상함수) , 가상함수:"함수 내용을 정의하지 않고, 자식 class에 의해 내용 결정"

---
어디에 넣어야 할까 ..
static local variable 특징 2가지 : block을 벗어나도 소멸되지 않는다.

process는 실행중인 program으로 , stack ,data, code   memory 영역을 독립적으로 가지고 있다.
Thread는 process 내의 data, code 영역을 **공유** 하고 stack 영역을 독립적으로 가지고 있다.




